const e=JSON.parse('{"key":"v-7ddbf8e5","path":"/java/01-volatile.html","title":"volatile","lang":"en-US","frontmatter":{"title":"volatile","icon":"page","order":1,"author":"luoliang","date":"2023-01-08T00:00:00.000Z","category":["java"],"tag":["基础知识"],"sticky":false,"star":true,"footer":false,"copyright":"No Copyright","editLink":false,"comment":false,"description":"volatile的作用 多线程的可见性 禁止重排序 可见性问题是怎么产生的？ 在单核CPU的场景，其实不存在可见性问题，因为只有一个cpu在执行，每次都能拿到最新的数据。 在多核cpu环境下，由于每个cpu都有自己的cache，数据先到cache中，CPU在自己的cache中修改，不会马上同步到主内存。 在硬件层面，有MESI协议保证 cache的同步，CPU工程师为了提高性能，增加了storebuffer和 invalidate queue又导致了数据不一致的问题，这个问题的解决交给了软件工程师，提供了内存屏障给软件工程师，在需求保证数据一致性的地方加上内存屏障。","head":[["meta",{"property":"og:url","content":"https://www.luoliang.top/java/01-volatile.html"}],["meta",{"property":"og:site_name","content":"luoliang"}],["meta",{"property":"og:title","content":"volatile"}],["meta",{"property":"og:description","content":"volatile的作用 多线程的可见性 禁止重排序 可见性问题是怎么产生的？ 在单核CPU的场景，其实不存在可见性问题，因为只有一个cpu在执行，每次都能拿到最新的数据。 在多核cpu环境下，由于每个cpu都有自己的cache，数据先到cache中，CPU在自己的cache中修改，不会马上同步到主内存。 在硬件层面，有MESI协议保证 cache的同步，CPU工程师为了提高性能，增加了storebuffer和 invalidate queue又导致了数据不一致的问题，这个问题的解决交给了软件工程师，提供了内存屏障给软件工程师，在需求保证数据一致性的地方加上内存屏障。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-02-05T13:59:28.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:author","content":"luoliang"}],["meta",{"property":"article:tag","content":"基础知识"}],["meta",{"property":"article:published_time","content":"2023-01-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-05T13:59:28.000Z"}]]},"headers":[{"level":2,"title":"volatile的作用","slug":"volatile的作用","link":"#volatile的作用","children":[]},{"level":2,"title":"可见性问题是怎么产生的？","slug":"可见性问题是怎么产生的","link":"#可见性问题是怎么产生的","children":[]},{"level":2,"title":"volatile的底层原理","slug":"volatile的底层原理","link":"#volatile的底层原理","children":[]}],"git":{"createdTime":1674001156000,"updatedTime":1675605568000,"contributors":[{"name":"weiluoliang","email":"wll000000","commits":2}]},"readingTime":{"minutes":0.81,"words":243},"filePathRelative":"java/01-volatile.md","localizedDate":"January 8, 2023","excerpt":"<h2> volatile的作用</h2>\\n<ol>\\n<li>多线程的可见性</li>\\n<li>禁止重排序</li>\\n</ol>\\n<h2> 可见性问题是怎么产生的？</h2>\\n<p>在单核CPU的场景，其实不存在可见性问题，因为只有一个cpu在执行，每次都能拿到最新的数据。</p>\\n<p>在多核cpu环境下，由于每个cpu都有自己的cache，数据先到cache中，CPU在自己的cache中修改，不会马上同步到主内存。</p>\\n<p>在硬件层面，有MESI协议保证 cache的同步，CPU工程师为了提高性能，增加了storebuffer和 invalidate queue又导致了数据不一致的问题，这个问题的解决交给了软件工程师，提供了内存屏障给软件工程师，在需求保证数据一致性的地方加上内存屏障。</p>","autoDesc":true}');export{e as data};
