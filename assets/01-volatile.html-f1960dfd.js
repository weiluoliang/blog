import{_ as e,V as a,W as l,X as t}from"./framework-fdd96744.js";const c={},i=t('<h2 id="volatile的作用" tabindex="-1"><a class="header-anchor" href="#volatile的作用" aria-hidden="true">#</a> volatile的作用</h2><ol><li>多线程的可见性</li><li>禁止重排序</li></ol><h2 id="可见性问题是怎么产生的" tabindex="-1"><a class="header-anchor" href="#可见性问题是怎么产生的" aria-hidden="true">#</a> 可见性问题是怎么产生的？</h2><p>在单核CPU的场景，其实不存在可见性问题，因为只有一个cpu在执行，每次都能拿到最新的数据。</p><p>在多核cpu环境下，由于每个cpu都有自己的cache，数据先到cache中，CPU在自己的cache中修改，不会马上同步到主内存。</p><p>在硬件层面，有MESI协议保证 cache的同步，CPU工程师为了提高性能，增加了storebuffer和 invalidate queue又导致了数据不一致的问题，这个问题的解决交给了软件工程师，提供了内存屏障给软件工程师，在需求保证数据一致性的地方加上内存屏障。</p><h2 id="volatile的底层原理" tabindex="-1"><a class="header-anchor" href="#volatile的底层原理" aria-hidden="true">#</a> volatile的底层原理</h2><p>lock关键字</p>',8),o=[i];function r(h,d){return a(),l("div",null,o)}const s=e(c,[["render",r],["__file","01-volatile.html.vue"]]);export{s as default};
